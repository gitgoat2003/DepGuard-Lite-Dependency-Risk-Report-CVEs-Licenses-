"""Report generation module for DepGuard Lite."""

from __future__ import annotations

import csv
import html
import io
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from depguard.models import (
    License,
    LicenseType,
    Package,
    ScanResult,
    Severity,
    Vulnerability,
)


class ReportGenerator:
    """Base class for report generators."""
    
    def generate(self, result: ScanResult) -> str:
        """Generate report from scan result."""
        raise NotImplementedError


class MarkdownReportGenerator(ReportGenerator):
    """Generate markdown reports for PRs and documentation."""
    
    def __init__(
        self,
        include_executive_summary: bool = True,
        collapsible_details: bool = True,
        include_upgrade_commands: bool = True,
        max_vulnerabilities_per_package: int = 10,
    ):
        self.include_executive_summary = include_executive_summary
        self.collapsible_details = collapsible_details
        self.include_upgrade_commands = include_upgrade_commands
        self.max_vulns = max_vulnerabilities_per_package
    
    def generate(self, result: ScanResult) -> str:
        """Generate markdown report."""
        lines = []
        
        # Header
        lines.append("# üõ°Ô∏è DepGuard Lite Security Report\n")
        lines.append(f"**Generated:** {result.scan_date.strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"**Project:** {result.project_name or 'Unknown'}")
        lines.append(f"**Dependencies Analyzed:** {len(result.packages)}\n")
        lines.append("---\n")
        
        # Executive Summary
        if self.include_executive_summary:
            lines.append(self._generate_summary(result))
        
        # Vulnerabilities by severity
        severity_breakdown = result.severity_breakdown()
        
        if severity_breakdown[Severity.CRITICAL] > 0:
            lines.append(self._generate_severity_section(
                result, Severity.CRITICAL, "üö® Critical Vulnerabilities"
            ))
        
        if severity_breakdown[Severity.HIGH] > 0:
            lines.append(self._generate_severity_section(
                result, Severity.HIGH, "üü° High Severity Vulnerabilities"
            ))
        
        if severity_breakdown[Severity.MEDIUM] > 0:
            lines.append(self._generate_severity_section(
                result, Severity.MEDIUM, "üü† Medium Severity Vulnerabilities"
            ))
        
        # License Analysis
        lines.append(self._generate_license_section(result))
        
        # Recommendations
        lines.append(self._generate_recommendations(result))
        
        # Risk Score
        lines.append(self._generate_risk_score(result))
        
        # Footer
        lines.append("---\n")
        lines.append("<sub>Generated by [DepGuard Lite](https://github.com/gitgoat2003/DepGuard-Lite) v1.0.0</sub>")
        
        return "\n".join(lines)
    
    def _generate_summary(self, result: ScanResult) -> str:
        """Generate executive summary section."""
        severity_breakdown = result.severity_breakdown()
        license_breakdown = result.license_breakdown()
        
        lines = ["## üìä Executive Summary\n"]
        
        # Determine overall status
        if severity_breakdown[Severity.CRITICAL] > 0:
            status = "üî¥ Action Required"
        elif severity_breakdown[Severity.HIGH] > 0:
            status = "üü° Review Recommended"
        elif result.total_vulnerabilities > 0:
            status = "üü† Minor Issues"
        else:
            status = "‚úÖ All Clear"
        
        lines.append("| Metric | Count | Status |")
        lines.append("|--------|-------|--------|")
        lines.append(f"| Total Vulnerabilities | {result.total_vulnerabilities} | {status} |")
        lines.append(f"| Critical Severity | {severity_breakdown[Severity.CRITICAL]} | {Severity.CRITICAL.emoji if severity_breakdown[Severity.CRITICAL] else '‚úÖ'} |")
        lines.append(f"| High Severity | {severity_breakdown[Severity.HIGH]} | {Severity.HIGH.emoji if severity_breakdown[Severity.HIGH] else '‚úÖ'} |")
        lines.append(f"| Medium Severity | {severity_breakdown[Severity.MEDIUM]} | {Severity.MEDIUM.emoji if severity_breakdown[Severity.MEDIUM] else '‚úÖ'} |")
        
        # License issues
        copyleft_count = license_breakdown.get(LicenseType.COPYLEFT, 0)
        unknown_count = license_breakdown.get(LicenseType.UNKNOWN, 0)
        license_issues = copyleft_count + unknown_count
        
        if license_issues > 0:
            lines.append(f"| License Issues | {license_issues} | ‚ö†Ô∏è Review Needed |")
        
        lines.append(f"| **Overall Risk Score** | **{result.risk_score}/10** | **{'üî¥ High Risk' if result.risk_score >= 7 else 'üü° Medium Risk' if result.risk_score >= 4 else 'üü¢ Low Risk'}** |")
        lines.append("\n---\n")
        
        return "\n".join(lines)
    
    def _generate_severity_section(
        self,
        result: ScanResult,
        severity: Severity,
        title: str,
    ) -> str:
        """Generate section for a specific severity level."""
        lines = [f"## {title}\n"]
        
        for pkg in result.packages:
            vulns = [v for v in pkg.vulnerabilities if v.severity == severity]
            if not vulns:
                continue
            
            if self.collapsible_details:
                lines.append(f"<details>")
                lines.append(f"<summary><strong>{pkg.name} {pkg.version}</strong> - {len(vulns)} {severity.value.title()} Vulnerabilities</summary>\n")
            else:
                lines.append(f"### {pkg.name} {pkg.version}\n")
            
            for vuln in vulns[:self.max_vulns]:
                lines.append(self._format_vulnerability(vuln, pkg))
            
            if len(vulns) > self.max_vulns:
                lines.append(f"\n*+ {len(vulns) - self.max_vulns} more vulnerabilities*\n")
            
            if self.collapsible_details:
                lines.append("</details>\n")
        
        lines.append("")
        return "\n".join(lines)
    
    def _format_vulnerability(self, vuln: Vulnerability, pkg: Package) -> str:
        """Format a single vulnerability."""
        lines = []
        
        cvss_str = f"CVSS {vuln.cvss.score}" if vuln.cvss else "CVSS N/A"
        lines.append(f"#### {vuln.id} ({cvss_str})")
        lines.append(f"- **Severity:** {vuln.severity.emoji} {vuln.severity.value.title()}")
        lines.append(f"- **Description:** {vuln.summary or 'No description available'}")
        
        if vuln.affected_versions:
            lines.append(f"- **Affected Versions:** {vuln.affected_versions}")
        
        if vuln.fixed_versions:
            lines.append(f"- **Fixed In:** {', '.join(vuln.fixed_versions)}")
        
        if self.include_upgrade_commands and vuln.fixed_versions:
            fixed = vuln.fixed_versions[0]
            if pkg.ecosystem == "pypi":
                lines.append(f"\n**Recommendation:**")
                lines.append(f"```bash")
                lines.append(f"pip install --upgrade \"{pkg.name}>={fixed}\"")
                lines.append(f"```\n")
            elif pkg.ecosystem == "npm":
                lines.append(f"\n**Recommendation:**")
                lines.append(f"```bash")
                lines.append(f"npm install {pkg.name}@{fixed}")
                lines.append(f"```\n")
        
        return "\n".join(lines)
    
    def _generate_license_section(self, result: ScanResult) -> str:
        """Generate license analysis section."""
        lines = ["## ‚öñÔ∏è License Analysis\n"]
        
        license_breakdown = result.license_breakdown()
        
        lines.append("### üìã License Distribution\n")
        lines.append("| License Type | Count | Risk Level |")
        lines.append("|--------------|-------|------------|")
        
        permissive = license_breakdown.get(LicenseType.PERMISSIVE, 0)
        lines.append(f"| Permissive (MIT, Apache, BSD) | {permissive} | ‚úÖ Low |")
        
        copyleft = license_breakdown.get(LicenseType.COPYLEFT, 0)
        if copyleft > 0:
            lines.append(f"| Copyleft (GPL, LGPL) | {copyleft} | ‚ö†Ô∏è High |")
        
        unknown = license_breakdown.get(LicenseType.UNKNOWN, 0)
        if unknown > 0:
            lines.append(f"| Unknown | {unknown} | ‚ùì Review |")
        
        lines.append("")
        
        # Flag packages requiring review
        review_packages = [
            pkg for pkg in result.packages
            if pkg.license and pkg.license.requires_review
        ]
        
        if review_packages:
            lines.append("### ‚ö†Ô∏è License Issues Requiring Review\n")
            
            for pkg in review_packages:
                if self.collapsible_details:
                    lines.append(f"<details>")
                    lines.append(f"<summary><strong>{pkg.name} {pkg.version}</strong> - {pkg.license.name}</summary>\n")
                else:
                    lines.append(f"#### {pkg.name} {pkg.version} - {pkg.license.name}\n")
                
                lines.append(f"**Risk Level:** {'üî¥ High' if pkg.license.copyleft else '‚ö†Ô∏è Medium'}\n")
                
                if pkg.license.copyleft:
                    lines.append("**Implications:**")
                    lines.append("- Your project may need to adopt the same license")
                    lines.append("- Source code distribution required for derivative works")
                    lines.append("- Incompatible with proprietary software\n")
                
                if self.collapsible_details:
                    lines.append("</details>\n")
        
        lines.append("")
        return "\n".join(lines)
    
    def _generate_recommendations(self, result: ScanResult) -> str:
        """Generate actionable recommendations section."""
        lines = ["## üéØ Actionable Recommendations\n"]
        
        # Critical fixes
        critical_pkgs = [
            pkg for pkg in result.packages
            if any(v.severity == Severity.CRITICAL for v in pkg.vulnerabilities)
        ]
        
        if critical_pkgs:
            lines.append("### Priority 1: Critical Security Fixes")
            lines.append("```bash")
            
            for pkg in critical_pkgs:
                fixed_versions = []
                for vuln in pkg.vulnerabilities:
                    fixed_versions.extend(vuln.fixed_versions)
                
                if fixed_versions:
                    latest_fix = max(fixed_versions)
                    if pkg.ecosystem == "pypi":
                        lines.append(f"pip install --upgrade {pkg.name}>={latest_fix}")
                    elif pkg.ecosystem == "npm":
                        lines.append(f"npm install {pkg.name}@{latest_fix}")
            
            lines.append("```\n")
        
        # High severity fixes
        high_pkgs = [
            pkg for pkg in result.packages
            if any(v.severity == Severity.HIGH for v in pkg.vulnerabilities)
            and pkg not in critical_pkgs
        ]
        
        if high_pkgs:
            lines.append("### Priority 2: High Severity Fixes")
            lines.append("```bash")
            
            for pkg in high_pkgs:
                fixed_versions = []
                for vuln in pkg.vulnerabilities:
                    fixed_versions.extend(vuln.fixed_versions)
                
                if fixed_versions:
                    latest_fix = max(fixed_versions)
                    if pkg.ecosystem == "pypi":
                        lines.append(f"pip install --upgrade {pkg.name}>={latest_fix}")
            
            lines.append("```\n")
        
        lines.append("")
        return "\n".join(lines)
    
    def _generate_risk_score(self, result: ScanResult) -> str:
        """Generate risk score visualization."""
        lines = ["## üìà Risk Score Breakdown\n"]
        
        score = result.risk_score
        filled = int(score)
        empty = 10 - filled
        
        bar = "‚ñà" * filled + "‚ñë" * empty
        
        lines.append("```")
        lines.append(f"Security Risk:    {bar} {score}/10")
        lines.append("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        lines.append(f"Overall Risk:     {bar} {score}/10")
        lines.append("```\n")
        
        return "\n".join(lines)


class JsonReportGenerator(ReportGenerator):
    """Generate JSON reports for machine-readable output."""
    
    def generate(self, result: ScanResult) -> str:
        """Generate JSON report."""
        data = {
            "metadata": {
                "tool": "DepGuard Lite",
                "version": "1.0.0",
                "scan_date": result.scan_date.isoformat(),
                "project_name": result.project_name,
                "dependency_file": result.dependency_file,
            },
            "summary": {
                "total_dependencies": len(result.packages),
                "vulnerable_dependencies": result.vulnerable_packages,
                "total_vulnerabilities": result.total_vulnerabilities,
                "severity_breakdown": {
                    s.value: count for s, count in result.severity_breakdown().items()
                },
                "license_breakdown": {
                    t.value: count for t, count in result.license_breakdown().items()
                },
                "risk_score": result.risk_score,
            },
            "vulnerabilities": [],
            "licenses": [],
            "recommendations": [],
        }
        
        # Add vulnerability details
        for pkg in result.packages:
            if pkg.vulnerabilities:
                pkg_data = {
                    "package": pkg.name,
                    "version": pkg.version,
                    "ecosystem": pkg.ecosystem,
                    "vulnerabilities": [],
                }
                
                for vuln in pkg.vulnerabilities:
                    vuln_data = {
                        "id": vuln.id,
                        "aliases": vuln.aliases,
                        "summary": vuln.summary,
                        "severity": vuln.severity.value,
                        "cvss_score": vuln.cvss.score if vuln.cvss else None,
                        "cvss_vector": vuln.cvss.vector if vuln.cvss else None,
                        "affected_versions": vuln.affected_versions,
                        "fixed_versions": vuln.fixed_versions,
                        "published": vuln.published.isoformat() if vuln.published else None,
                        "references": [
                            {"type": ref.type, "url": ref.url}
                            for ref in vuln.references
                        ],
                        "cwe": vuln.cwe,
                    }
                    pkg_data["vulnerabilities"].append(vuln_data)
                
                data["vulnerabilities"].append(pkg_data)
        
        # Add license details
        for pkg in result.packages:
            if pkg.license:
                license_data = {
                    "package": pkg.name,
                    "version": pkg.version,
                    "license": pkg.license.name,
                    "spdx_id": pkg.license.spdx_id,
                    "type": pkg.license.type.value,
                    "risk_level": pkg.license.risk.value,
                    "requires_review": pkg.license.requires_review,
                    "copyleft": pkg.license.copyleft,
                }
                data["licenses"].append(license_data)
        
        return json.dumps(data, indent=2, default=str)


class HtmlReportGenerator(ReportGenerator):
    """Generate HTML reports with styling."""
    
    def generate(self, result: ScanResult) -> str:
        """Generate HTML report."""
        # Generate markdown and convert to styled HTML
        md_generator = MarkdownReportGenerator()
        md_content = md_generator.generate(result)
        
        # Basic HTML wrapper with CSS
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DepGuard Lite Security Report</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: #0d1117;
            color: #c9d1d9;
        }}
        h1, h2, h3 {{ color: #58a6ff; }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }}
        th, td {{
            border: 1px solid #30363d;
            padding: 0.5rem;
            text-align: left;
        }}
        th {{ background: #21262d; }}
        code {{
            background: #161b22;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
        }}
        pre {{
            background: #161b22;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
        }}
        details {{
            background: #161b22;
            padding: 1rem;
            border-radius: 6px;
            margin: 0.5rem 0;
        }}
        summary {{
            cursor: pointer;
            color: #58a6ff;
        }}
        .severity-critical {{ color: #f85149; }}
        .severity-high {{ color: #d29922; }}
        .severity-medium {{ color: #db6d28; }}
        .severity-low {{ color: #3fb950; }}
    </style>
</head>
<body>
    <article>
{self._markdown_to_html(md_content)}
    </article>
</body>
</html>"""
        return html_content
    
    def _markdown_to_html(self, md: str) -> str:
        """Simple markdown to HTML conversion."""
        # This is a basic conversion; for production use a proper markdown library
        lines = md.split("\n")
        html_lines = []
        in_code_block = False
        in_list = False
        
        for line in lines:
            if line.startswith("```"):
                if in_code_block:
                    html_lines.append("</code></pre>")
                    in_code_block = False
                else:
                    html_lines.append("<pre><code>")
                    in_code_block = True
                continue
            
            if in_code_block:
                html_lines.append(html.escape(line))
                continue
            
            # Headers
            if line.startswith("# "):
                html_lines.append(f"<h1>{html.escape(line[2:])}</h1>")
            elif line.startswith("## "):
                html_lines.append(f"<h2>{html.escape(line[3:])}</h2>")
            elif line.startswith("### "):
                html_lines.append(f"<h3>{html.escape(line[4:])}</h3>")
            elif line.startswith("#### "):
                html_lines.append(f"<h4>{html.escape(line[5:])}</h4>")
            elif line.startswith("- "):
                if not in_list:
                    html_lines.append("<ul>")
                    in_list = True
                html_lines.append(f"<li>{html.escape(line[2:])}</li>")
            elif line.startswith("|"):
                # Table handling (simplified)
                html_lines.append(line)
            elif line.strip() == "":
                if in_list:
                    html_lines.append("</ul>")
                    in_list = False
                html_lines.append("")
            else:
                html_lines.append(f"<p>{html.escape(line)}</p>")
        
        return "\n".join(html_lines)


class CsvReportGenerator(ReportGenerator):
    """Generate CSV export for vulnerabilities."""
    
    def generate(self, result: ScanResult) -> str:
        """Generate CSV report."""
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Header
        writer.writerow([
            "Package", "Version", "Ecosystem", "Vulnerability ID",
            "Severity", "CVSS Score", "Summary", "Fixed In",
            "Published Date", "License", "License Type"
        ])
        
        # Data rows
        for pkg in result.packages:
            license_name = pkg.license.name if pkg.license else ""
            license_type = pkg.license.type.value if pkg.license else ""
            
            if pkg.vulnerabilities:
                for vuln in pkg.vulnerabilities:
                    writer.writerow([
                        pkg.name,
                        pkg.version,
                        pkg.ecosystem,
                        vuln.id,
                        vuln.severity.value,
                        vuln.cvss.score if vuln.cvss else "",
                        vuln.summary,
                        ", ".join(vuln.fixed_versions),
                        vuln.published.strftime("%Y-%m-%d") if vuln.published else "",
                        license_name,
                        license_type,
                    ])
            else:
                # Package with no vulnerabilities
                writer.writerow([
                    pkg.name,
                    pkg.version,
                    pkg.ecosystem,
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    license_name,
                    license_type,
                ])
        
        return output.getvalue()


class SarifReportGenerator(ReportGenerator):
    """Generate SARIF format for security tools integration."""
    
    def generate(self, result: ScanResult) -> str:
        """Generate SARIF report."""
        sarif = {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [{
                "tool": {
                    "driver": {
                        "name": "DepGuard Lite",
                        "version": "1.0.0",
                        "informationUri": "https://github.com/gitgoat2003/DepGuard-Lite",
                        "rules": [],
                    }
                },
                "results": [],
            }]
        }
        
        run = sarif["runs"][0]
        rules = {}
        
        for pkg in result.packages:
            for vuln in pkg.vulnerabilities:
                # Add rule if not already added
                if vuln.id not in rules:
                    rule = {
                        "id": vuln.id,
                        "name": vuln.id.replace("-", ""),
                        "shortDescription": {
                            "text": vuln.summary[:200] if vuln.summary else "No description"
                        },
                        "fullDescription": {
                            "text": vuln.details or vuln.summary or "No description"
                        },
                        "defaultConfiguration": {
                            "level": self._severity_to_sarif_level(vuln.severity)
                        },
                        "properties": {
                            "security-severity": str(vuln.cvss.score) if vuln.cvss else "0.0"
                        }
                    }
                    rules[vuln.id] = rule
                    run["tool"]["driver"]["rules"].append(rule)
                
                # Add result
                result_entry = {
                    "ruleId": vuln.id,
                    "level": self._severity_to_sarif_level(vuln.severity),
                    "message": {
                        "text": f"Package {pkg.name}@{pkg.version} has vulnerability {vuln.id}: {vuln.summary}"
                    },
                    "locations": [{
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": result.dependency_file or "requirements.txt",
                                "uriBaseId": "%SRCROOT%"
                            }
                        }
                    }],
                    "properties": {
                        "package": pkg.name,
                        "version": pkg.version,
                        "fixedIn": vuln.fixed_versions,
                    }
                }
                run["results"].append(result_entry)
        
        return json.dumps(sarif, indent=2)
    
    def _severity_to_sarif_level(self, severity: Severity) -> str:
        """Convert severity to SARIF level."""
        mapping = {
            Severity.CRITICAL: "error",
            Severity.HIGH: "error",
            Severity.MEDIUM: "warning",
            Severity.LOW: "note",
            Severity.UNKNOWN: "none",
        }
        return mapping.get(severity, "none")


# Factory for report generators
REPORT_GENERATORS = {
    "markdown": MarkdownReportGenerator,
    "md": MarkdownReportGenerator,
    "json": JsonReportGenerator,
    "html": HtmlReportGenerator,
    "csv": CsvReportGenerator,
    "sarif": SarifReportGenerator,
}


def generate_report(
    result: ScanResult,
    format: str = "markdown",
    **kwargs,
) -> str:
    """Generate a report in the specified format.
    
    Args:
        result: Scan result to report on
        format: Report format (markdown, json, html, csv, sarif)
        **kwargs: Additional options for the generator
    
    Returns:
        Report content as string
    """
    format_lower = format.lower()
    
    if format_lower not in REPORT_GENERATORS:
        raise ValueError(f"Unknown report format: {format}")
    
    generator_class = REPORT_GENERATORS[format_lower]
    generator = generator_class(**kwargs) if kwargs else generator_class()
    
    return generator.generate(result)


def save_report(
    result: ScanResult,
    output_path: Path,
    format: Optional[str] = None,
    **kwargs,
) -> None:
    """Save report to a file.
    
    Args:
        result: Scan result to report on
        output_path: Path to save the report
        format: Report format (auto-detected from extension if not provided)
        **kwargs: Additional options for the generator
    """
    output_path = Path(output_path)
    
    # Auto-detect format from extension
    if format is None:
        ext = output_path.suffix.lower().lstrip(".")
        format = ext if ext in REPORT_GENERATORS else "markdown"
    
    content = generate_report(result, format, **kwargs)
    output_path.write_text(content, encoding="utf-8")


def format_for_pr_comment(result: ScanResult, max_length: int = 65000) -> str:
    """Format report for GitHub PR comment.
    
    GitHub has a 65,536 character limit for comments.
    """
    generator = MarkdownReportGenerator(
        include_executive_summary=True,
        collapsible_details=True,
        include_upgrade_commands=True,
        max_vulnerabilities_per_package=3,
    )
    
    content = generator.generate(result)
    
    # Truncate if needed
    if len(content) > max_length:
        truncate_msg = "\n\n---\n*Report truncated. Run `depguard scan` locally for full details.*"
        content = content[:max_length - len(truncate_msg)] + truncate_msg
    
    return content
